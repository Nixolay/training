# Типы данных: строки.

При написании этого урока у меня возникла дилемма. Я не знал с чего начать, с строк или массивов. В итоге решил объединить их в один, так как они взаимосвязанны. Возможно некоторые, по мере изучения этого урока зададутся вопросом, почему тогда я не включил в этот урок структуры, но я могу дать на это два ответа:
* Для понимания строк не нужны структуры.
* Это мой урок и я диктую тут правила. Хахаха.

## Массивы

Массивом называют упорядоченный набор элементов фиксированной длины.
Так, с терминологией мы разобрались, давай посмотрим как мы будем создавать работать с ним в Go.
Создадим простой пример:
```go:
var arr [8]int64
```
В данном примере мы создали массив в памяти из 8-ми элементов типа `int64`, так как тип занимает 64 бита, то в итоге получаем выделенный целый кусок памяти на 8х64 = 512 бит.

Можно сразу заполнить в массиве некоторые элементы:
```go:
arr := [8]int64{1, 2, 3}
```
Тогда получи массив `[8]int64{1, 2, 3, 0, 0, 0, 0, 0}`, остальные элементы будут нули, так как по умолчанию все числа равны нулю.

Примеры обращения к элементу массива или его изменить.
```go:
arr := [8]int64{1, 2, 3}
println(arr[0]) // выведет 1
arr[3] = 4 // Получим массив [8]int64{1, 2, 3, 4, 0, 0, 0, 0}
```

## Slice(срезы)
https://go.dev/src/runtime/slice.go
```go:
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```
Слайсы - это опять же структура, которая хранит в себе:
- array указатель на массив
- len количество элементов, которые сейчас содержатся в срезе.
- cap который определяет общее количество предоставленных ячеек памяти.

Создать слайс можно несколькими способами:
```go:
var slice0 []int                     // len=0, cap=0
slice1 := []int{6, 1, 2}             // len=3,cap=3
slice2 := make([]int, 0, 3)          // len=0,cap=3
slice3 := append([]int{}, slice2...) // len=0, cap=0
slice4 := append(slice1, 3)          // len=4, cap=6
```

При использовании функции `append`, когда новый элемент нельзя будет положить в массив по ссылке, так как массив уже заполнен, `append` создаст новый массив с большей длинной в два раза.

Так как слайс имеет указатель на массив, то когда мы будем передавать его в функцию/метод и если функция решит изменить элементы внутри слайса, они изменятся и везде где используется этот слайс. Но это до тех пор пока указатель не изменится на другой массив.

# string
Строка очень похожа на слайсы, только у нее отсутствует вместимость(capacity) и строки неизменны.
```
type stringStruct struct {
	str unsafe.Pointer
	len int
}
```
одна из причин по которой мы передаем в `cap` длину при преобразовании строки в слайс байт.
```
func UnsafeStringToByteSliceByHeader(s string) []byte {
	var b []byte

	bp := (*reflect.SliceHeader)(unsafe.Pointer(&b))
	sp := (*reflect.StringHeader)(unsafe.Pointer(&s))

	bp.Data = sp.Data
	bp.Len = sp.Len
	bp.Cap = sp.Len

	return b
}
```

Строка фактически представляет собой последовательность байтов UTF-8. В UTF-8 символы ASCII являются однобайтовыми, соответствующими первым 128 символам Юникода. Все остальные символы имеют размер от 1 до 4 байт. Поэтому есть некоторые проблемы при получении длинны строки.
```
sample := "Привет мир! 你好世界!"
println(utf8.RuneCountInString(sample)) // 17
println(len([]rune(sample)))            // 17
println(len(sample))                    // 34
```

При использовании `range` мы будем получать из строки `rune`
```
func TestString(t *testing.T) {
	sample := "Привет мир! 你好世界!"
	for _, data := range sample {
		PrintType(data)
	}
}

func PrintType(data interface{}) {
	switch v := data.(type) {
	case rune:
		println("rune:", v)
	default:
		println("not rune:", v)
	}
}
```
Так как `rune` является алиасом `int32`, то в данном примере мы получим на вывод числа.