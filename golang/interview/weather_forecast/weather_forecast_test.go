package weatherforecast

import (
	"fmt"
	"math/rand"
	"net/http"
	"time"
)

// 1) Есть функция, которая через нейронную сеть вычисляет прогноз погоды за ~1 секунду
// 2) Есть highload RPC ручка с нагрузкой 10k RPS
// 3) Необходимо реализовать код этой ручки
//
// Дополнительные вопросы
// 1) А что если нам теперь приходит параметр cityld и нам надо отдавать погоду для него?
// 2) Что будет если каждый раз ходить в микросервис?
// 2.1) каждый запрос будет обрабатываться по секунде, а это дополнительный расход памяти, CPU и т.д
// 3) Какой таймаут правильно выставить на ручку вызов aiWeatherForecast?
// 4) Если человек додумался сделать кеш со словариком, то какие нештатные ситуации могут случиться?
// 4.1) Прогрев кеша, протухание кеша, одновременное протухание кеша и т.п..
// 4.2) Как предотвратить эти ситуации?
// 5) Как выглядит НТТР-запрос и ответ
// 5.1) Method, URL, Headers, Body
// 5.2) Статусы НТТР-ответов (нужно принципиально отличать 200, 400 и 500, знать как их обрабатывать)
// 5.3) Путь запроса от пользовательского приложения до сервера и обратно (шифрование, сокеты, буферы, DNS, IP, роутеры, MTU, таблицы маршрутизации, фаерволы, почему витая пара витая)
//
// Экспертные вопросы
// 1) Какую структуру правильно выбрать для кэша?
// 2) Как исключить гонки при параллельном доступе к структуре?
// 3) Как инвалидировать кеш?
// 4) Как реализовать прогрев кеша перед стартом приложения?
// aiWeatherForecast через нейронную сеть вычисляет прогноз погоды за ~1 секунду
func aiWeatherForecast() int {
	time.Sleep(1 * time.Second)
	return rand.Intn(40)
}

func main() {
	http.HandleFunc("/weather", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "{\"temperature\":%d}\n", aiWeatherForecast())
	})
	if err := http.ListenAndServe(":5000", nil); err != nil {
		panic(err)
	}
}
