package leetcode

import (
	"testing"

	"github.com/stretchr/testify/require"
)

/*
	Вам предоставлены два непустых связанных списка, представляющих два неотрицательных целых числа.
Цифры хранятся в обратном порядке, и каждый из их узлов содержит одну цифру.
Сложите два числа и верните сумму в виде связанного списка.
	Вы можете предположить, что эти два числа не содержат никакого начального нуля,
за исключением самого числа 0.



Пример 1:
	Ввод: l1 = [2,4,3], l2 = [5,6,4]
	Вывод: [7,0,8]
	Пояснение: 342 + 465 = 807.

Пример 2:
	Ввод: l1 = [0], l2 = [0]
	Вывод: [0]

Пример 3:
	Ввод: l1 = [9,9,9,9,9,9], l2 = [9,9,9,9]
	Вывод: [8,9,9,9,0,0,0,1]


Ограничения:
	Количество узлов в каждом связанном списке находится в диапазоне [1, 100].
	0 <= Node.val <= 9
	Гарантируется, что список представляет число, в котором нет начальных нулей.
*/

func TestAddTwoNumbers(t *testing.T) {
	type testData struct {
		l1       *ListNode
		l2       *ListNode
		expected *ListNode
	}

	data := []testData{
		{
			&ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3, Next: nil}}},
			&ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4, Next: nil}}},
			&ListNode{Val: 7, Next: &ListNode{Val: 0, Next: &ListNode{Val: 8, Next: nil}}},
		},
		{&ListNode{Val: 0, Next: nil}, &ListNode{Val: 0, Next: nil}, &ListNode{Val: 0, Next: nil}},
	}

	for _, v := range data {
		require.Equal(t, v.expected, addTwoNumbers(v.l1, v.l2))
	}
}

// ListNode определяет структуру узла односвязного списка.
type ListNode struct {
	Val  int
	Next *ListNode
}

// addTwoNumbers складывает два числа, представленные в виде связанных списков, и возвращает результат как связанный список.
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	// Создаем фиктивный узел для упрощения добавления новых узлов.
	dummy := &ListNode{}
	current := dummy // Указатель на текущий узел в результирующем списке.
	carry := 0       // Переменная для хранения переноса при сложении.

	// Цикл продолжается, пока есть элементы в списках l1 или l2, или пока есть перенос.
	for l1 != nil || l2 != nil || carry != 0 {
		// Получаем значения текущих узлов из l1 и l2, если они существуют.
		var val1, val2 int
		if l1 != nil {
			val1 = l1.Val
			l1 = l1.Next // Переходим к следующему узлу в l1.
		}
		if l2 != nil {
			val2 = l2.Val
			l2 = l2.Next // Переходим к следующему узлу в l2.
		}

		// Считаем сумму значений узлов и переноса.
		sum := val1 + val2 + carry
		carry = sum / 10 // Обновляем перенос (если сумма больше или равна 10).
		sum = sum % 10   // Оставляем только последнюю цифру суммы.

		// Создаем новый узел с вычисленным значением и добавляем его к результирующему списку.
		current.Next = &ListNode{Val: sum}
		current = current.Next // Переходим к следующему узлу в результирующем списке.
	}

	// Возвращаем следующий узел после фиктивного (он содержит начало результирующего списка).
	return dummy.Next
}

/*
dummy - фиктивный узел, который используется для упрощения создания результирующего списка.
current - указатель на текущий узел в результирующем списке.
carry - переменная для хранения переноса при сложении двух цифр.

Основной цикл:
	Цикл продолжается, пока хотя бы один из списков не пуст и пока есть ненулевой перенос.
	val1 и val2 получают значения текущих узлов из списков l1 и l2, если они существуют.
	sum хранит сумму значений текущих узлов и переноса.
	carry обновляется значением целой части от деления sum на 10.
	Новый узел с остатком от деления sum на 10 добавляется к результирующему списку.
*/
