Подготовка к собеседованию Go (Senior)
1. Преимущества Go
Простота синтаксиса, встроенные инструменты (fmt, test, race detector), быстрая компиляция, эффективная конкурентность через горутины и каналы, кроссплатформенность и читаемость кода.

2. Конкурентность и горутины
Горутины — лёгкие задачи, запускаемые Go-рантаймом. Они дешевле потоков ОС, имеют небольшой стек и масштабируются тысячами. Планируются моделью M:N (много горутин на несколько потоков ОС).

3. Недостатки Go
Много бойлерплейта (например, при обработке ошибок), нет удобного pattern matching, ограниченные дженерики, управление памятью только через GC, ограниченный функционал языка по сравнению с Rust/Java.

4. Система типов
Простая и строгая. Есть структуры, интерфейсы, массивы, слайсы, мапы. Нет тьюплов. Приведение типов иногда требует ручного каста. Интерфейсы позволяют абстракции, но требуют явной реализации.

5. Императивный vs декларативный подход
Императивный: мы описываем, как выполнить задачу, а не что получить.

6. Обобщённое программирование
Дженерики (с Go 1.18), интерфейсы, кодогенерация, рефлексия. Дженерики удобнее всего, но интерфейсы остаются базовым механизмом.

7. defer
Откладывает выполнение функции до выхода из текущей. Выполняется в обратном порядке. Удобен для закрытия ресурсов и обработки паник.

8. Слайсы
Слайс — это дескриптор (указатель на массив, длина, capacity). Массив — фиксированный блок памяти. При append capacity увеличивается по определённой стратегии (обычно ×2).
Преобразовать слайс в массив, через копирование элементов (copy) или явно указав тип [N]T(s) при достаточной длине.

9. Map в Go(Структура set)
- Ключами могут быть любые сравнимые типы: числа, строки, bool, указатели, структуры без слайсов/мапов/функций. Слайсы нельзя, так как они несравнимы.
- Хэш-таблица с бакетами. При коллизиях элементы распределяются по цепочкам внутри бакета. Время доступа — амортизированно O(1).
- Порядок обхода map нестабильный и псевдослучайный. Это сделано специально, чтобы разработчики не полагались на порядок.
- sync.Map - Оптимизирован для конкурентного доступа при большом числе читателей и редких изменениях.

10. Каналы
Безопасный способ передачи данных между горутинами. Бывают буферизованные и небуферизованные.
Небуферизованный канал отправитель блокируется, пока получатель не прочтёт значение (и наоборот). Передаются данные копированием, а не ссылкой.

11. Linux и системные вопросы
Файловые системы (XFS, EXT4): отличаются структурой хранения метаданных и размером inode.
Симлинк vs хардлинк: симлинк хранит путь к файлу, хардлинк — дополнительная запись имени на тот же inode.
Права доступа 774: владелец — rwx, группа — rw, остальные — r.
kill: посылает сигнал процессу. Некоторые сигналы можно обработать, но SIGKILL и SIGSTOP — нет.
SIGPIPE: возникает при записи в закрытый пайп.

12. Git
Объекты в Git: Commit (снимок изменений), branch (указатель на коммит), tag (именованная ссылка), tree (каталог), blob (файл).

13. Базы данных и производительность
Анализировать проблемы с производительностью БД:
 Собрать метрики, изучить slowlog, проанализировать индексы и нагрузку. Разделить нагрузку на чтение/запись. Использовать кэширование, шардирование или партицирование при необходимости.
Риски шардирования:
 Усложняет администрирование, повышает стоимость поддержки, требует продуманного дизайна ключей.

14. Кэширование
Реализовать кэш поверх БД:
 Ввести интерфейс Cache с методами Get/Set. Реализация может быть на map + RWMutex или sync.Map. Для конкурентности использовать atomic/pattern "copy-on-write".
 Через TTL, полное сброс, lazy-инвалидацию на чтение. Выбор зависит от SLA.
 Hit ratio, memory usage, количество запросов, latency.

15. Диагностика и восстановление сервиса
 Использовать метрики (CPU, память, диск, сеть), логи, трейсы. Сначала локализовать проблему (БД, сеть, код), потом оптимизировать.

16. Роль разработчика
Решать сложные технические задачи, делиться опытом, помогать команде, думать о масштабируемости и надежности решений, задавать правильные вопросы о нагрузке и инфраструктуре.

18. Чем отличается поток от процесса?
Процесс — изолированная единица с собственной памятью. Поток — часть процесса, делит память с другими потоками.

19. Чем отличается контейнеризация от виртуализации?
Виртуализация эмулирует целую ОС, контейнеризация — только среду приложения поверх одной ОС.

20. Есть ли структура set в Go?
Нет встроенной, обычно используют map[T]struct{}.

21. модели OSI:
- Физический (кабели/сигналы)
- Канальный (передача кадров)
- Сетевой (IP-адреса/маршруты)
- Транспортный (TCP/UDP, доставка)
- Сеансовый (подключение/сессия)
- Представительный (шифрование/формат)
- Прикладной (приложения/HTTP).

22. Какие системы могут понадобиться при интеграциях?
Message broker (Kafka, RabbitMQ), API Gateway, ETL, сервис авторизации, мониторинг.

23. Паттерны интеграций:
Point-to-Point (прямые связи) — системы общаются напрямую.
Hub-and-Spoke  (центр-шины)   — центральный узел управляет обменом.
ESB            (шина)    — единая шина с маршрутизацией и трансформацией сообщений.
API Gateway    (шлюз)    — единая точка входа в API для клиентов.
Event-Driven   (события) — взаимодействие через события и брокер сообщений

24. методы HTTP
GET    — получение данных
POST   — создание ресурса
PUT    — полное обновление
PATCH  — частичное обновление
DELETE — удаление

24. context.Context нужен:
Передача сигналов отмены, дедлайнов, метаданных между функциями.