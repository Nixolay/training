// Package syncpool ...
/*
* пул горутино-безопасен
* пул не обязательно освободит данные при первом пробуждении GC, но он может освободить их в любой момент
* нет возможности определить и установить размер пула
* нет необходимости заботится о переполнении пула
* вовсе незачем городить пул везде где ни попади,
	он создавался как амортизатор при множественном совместном использовании некоторых общих объектов,
	даже не просто внутри пакета, а даже больше — другими пакетами
* вероятно у Вас есть или будут ситуации, когда необходимость/возможность помочь GC будет очевидной
* пул ограниченного размера делается с помощью канала с буфером
*/
package syncpool

import (
	"sync"
)

// T тестирование пул экземпляров,
// которые могут быть повторно использованы для того,
// чтобы уменьшить давление на сборщик мусора.
func T() {
	var numCalcsCreated int

	calcPool := &sync.Pool{
		// Для инициализации объекта в памяти создаем функцию для New
		New: func() interface{} {
			numCalcsCreated++

			mem := make([]byte, 0, 1024)

			return &mem
		},
	}

	const numWorkers = 1024 * 1024

	var wg sync.WaitGroup

	wg.Add(numWorkers)

	for i := 0; i < numWorkers; i++ {
		go func() {
			defer wg.Done()

			// Получаем объект из пула
			mem, ok := calcPool.Get().(*[]byte)
			if !ok {
				println("incorrect type")
			}

			// После работы возвращаем обратно
			defer calcPool.Put(mem)
		}()
	}

	wg.Wait()
	println(numCalcsCreated, "calculate.")
}

// ----------------------------------------------------------------------------
//    Еще пример

/*
   так или иначе у нас могут оказаться слишком большие куски,
   которые в принципе нам не понадобятся (во всяком случае
   не часто) - выбросим их; иначе: кусок размером 2048 байт
   будет использоваться там где нужно всего 500-800 байт,
   при большом количестве это негативно отразится на памяти
   - а ведь мы с этим и боремся
*/
/* const maxCap = 1024

var bytesPool = sync.Pool{
	New: func() interface{} { return []byte{} },
}

// получить
func getBytes() (b []byte) {
	ifc := bytesPool.Get()
	if ifc != nil {
		b = ifc.([]byte)
	}
	return
}

// положить
func putBytes(b []byte) {
	if cap(b) <= maxCap {
		// пусть ary у нас []byte определённой длины и ёмкости
		b = b[:0]
		// усекаем len, сохраняем cap
		bytesPool.Put(b)
	}
} */
